Texture2D texScene : register(t0);
Texture2D normScene : register(t1);
Texture2D depthScene : register(t2);

SamplerState sLinear : register(s0);

cbuffer CB : register(b0)
{
	float2 pixelSize;
	float2 padding;
};

struct Input
{
	float4 position : SV_POSITION;
	float2 texCoord : TEXCOORD0;
};

struct Output
{
	float4 color : SV_TARGET;
};

static const float ANGLE_REJECT = 0.8f;
static const uint KERNEL_SIZE = 3;

float2 FindOffset(Texture2D depthBuffer, float currentDepth, int2 texCoord, float angleReject)
{
	float2 offset = 0.5f.xx;
	
	int kernelRadius = KERNEL_SIZE / 2;
	
	float depthXL = depthBuffer.Load(int3(texCoord + int2(-1, 0), 0)).x;
	float depthXR = depthBuffer.Load(int3(texCoord + int2(1, 0), 0)).x;
	float depthX2L = depthBuffer.Load(int3(texCoord + int2(-2, 0), 0)).x;
	float depthX2R = depthBuffer.Load(int3(texCoord + int2(2, 0), 0)).x;
	
	bool isXEdge = abs(depthXL + depthXR - 2.0f * currentDepth) > 0.0000001f * currentDepth;
	bool isSilhouette = false;
	
	if (isXEdge)
	{
		float depthDistanceL = depthXL - depthX2L;
		float depthDistanceR = depthX2R - depthXR;
		float augmentedDepthL = depthXL + depthDistanceL;
		float augmentedDepthR = depthXR - depthDistanceR;
		
		offset.x = (augmentedDepthR - augmentedDepthL) / (depthDistanceL - depthDistanceR);
		
		isSilhouette = abs(offset.x) > 1.0f;
		
		offset.x = (abs(offset.x) < 0.5f) ? offset.x : 0.5f;
	}
	
	float depthYD = depthBuffer.Load(int3(texCoord + int2(0, -1), 0)).x;
	float depthYU = depthBuffer.Load(int3(texCoord + int2(0, 1), 0)).x;
	float depthY2D = depthBuffer.Load(int3(texCoord + int2(0, -2), 0)).x;
	float depthY2U = depthBuffer.Load(int3(texCoord + int2(0, 2), 0)).x;
	
	bool isYEdge = abs(depthYD + depthYU - 2.0f * currentDepth) > 0.0000001f * currentDepth;
	
	if (isYEdge)
	{
		float depthDistanceD = depthYD - depthY2D;
		float depthDistanceU = depthY2U - depthYU;
		float augmentedDepthD = depthYD + depthDistanceD;
		float augmentedDepthU = depthYU - depthDistanceU;
		
		offset.y = (augmentedDepthU - augmentedDepthD) / (depthDistanceD - depthDistanceU);
		
		isSilhouette = abs(offset.y) > 1.0f;
		
		offset.y = (abs(offset.y) < 0.5f) ? offset.y : 0.5f;
	}
	
	if (abs(offset.x) > abs(offset.y))
	{
		offset.x = 0.0f;
		offset.y = ((offset.y >= 0)? 0.5f : -0.5f) - offset.y;
	}
	else
	{
		offset.x = ((offset.x >= 0)? 0.5f : -0.5f) - offset.x;
		offset.y = 0.0f;
	}
	
	return ((float)isSilhouette).xx;//offset;
}

float2 CalculateNormal(float2 forwardVector)
{
	float2 normal;
	normal.x = -forwardVector.y;
	normal.y = forwardVector.x;
	
	return normal;
}

Output main(Input input)
{
	Output output = (Output)0;
	
	float depth = depthScene.Load(int3((int2) input.position.xy, 0)).x;
	
	float2 offset = FindOffset(depthScene, depth, (int2) input.position.xy, ANGLE_REJECT);
	//offset = CalculateNormal(offset);
	//offset *= pixelSize;
	
	float3 color = texScene.Sample(sLinear, input.texCoord + offset).xyz;
	
	output.color = float4(offset, 0.0f, 1.0f);
	
	return output;
}
