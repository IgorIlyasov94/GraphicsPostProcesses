cbuffer CB : register(b0)
{
	float4x4 world;
	float4x4 worldView;
	float4x4 worldViewProj;
};

struct PointLight
{
	float3 viewSpacePosition;
	float radius;
	float3 color;
	float intensity;
};

struct BoundingBox
{
	float4 minCornerPoint;
	float4 maxCornerPoint;
};

StructuredBuffer<PointLight> pointLightBuffer : register(t0);
Texture3D<uint> pointLightCluster : register(t1);

StructuredBuffer<BoundingBox> clusterData : register(t2);

struct Input
{
	float4 position : SV_POSITION;
	float3 normal : NORMAL;
	float2 texCoord : TEXCOORD0;
	float4 clipCoord : TEXCOORD1;
	float4 worldCoord : TEXCOORD2;
};

struct Output
{
	float4 color : SV_TARGET0;
	float4 normal : SV_TARGET1;
};

static const uint CLUSTER_SIZE_X = 8;
static const uint CLUSTER_SIZE_Y = 6;
static const uint CLUSTER_SIZE_Z = 6;
static const uint CLUSTER_SIZE = CLUSTER_SIZE_X * CLUSTER_SIZE_Y * CLUSTER_SIZE_Z;
static const uint3 CLUSTER_SIZE_XYZ = uint3(CLUSTER_SIZE_X, CLUSTER_SIZE_Y, CLUSTER_SIZE_Z);
static const uint CLUSTER_LIGHTS_PER_CELL = 128;

uint3 Calculate3DAddress(float3 screenCoord, uint3 clusterSize)
{
	uint3 resultAddress;
	resultAddress.xy = (uint2) (screenCoord.xy * clusterSize.xy);
	resultAddress.z = (uint) (screenCoord.z * clusterSize.z);
	return resultAddress;
}

uint PackAddress(uint3 address, uint3 size)
{
	return (address.z * size.y + address.y) * size.x + address.x;
}

uint3 UnpackAddress(uint flatAddress, uint3 size)
{
	uint sizeXY = size.x * size.y;
	
	return uint3(flatAddress % size.x, (flatAddress % sizeXY) / size.x, flatAddress / sizeXY);
}

float LightAttenuation(float lightDistance, float lightRadius)
{
	return 1.0f - smoothstep(lightRadius * 0.75f, lightRadius, lightDistance);
}

float3 CalculateLighting(PointLight pointLight, float3 position, float3 normal)
{
	float3 lightDirection = position - pointLight.position;
	float lightDistance = length(lightDirection);
	lightDirection = lightDirection / lightDistance;
	
	float brightness = saturate(dot(lightDirection, -normal)) * LightAttenuation(lightDistance, pointLight.radius);
	
	return pointLight.color * pointLight.intensity * brightness;
}

struct Sphere
{
	float3 center;
	float radius;
};

bool IntersectionSphereAndBoundingBox(Sphere sphere, BoundingBox boundingBox)
{
	/*float3 closestPoint;
	closestPoint.x = max(boundingBox.minCornerPoint.x, min(boundingBox.maxCornerPoint.x, sphere.center.x));
	closestPoint.y = max(boundingBox.minCornerPoint.y, min(boundingBox.maxCornerPoint.y, sphere.center.y));
	closestPoint.z = max(boundingBox.minCornerPoint.z, min(boundingBox.maxCornerPoint.z, sphere.center.z));
	
	float closestDistance = length(sphere.center - closestPoint);
	
	return closestDistance <= sphere.radius;*/
	
	float sqDistance = 0.0f;

    for ( int i = 0; i < 3; ++i )
    {
        float v = sphere.center[i];

        if ( v < boundingBox.minCornerPoint[i] ) sqDistance += pow( boundingBox.minCornerPoint[i] - v, 2 );
        if ( v > boundingBox.maxCornerPoint[i] ) sqDistance += pow( v - boundingBox.maxCornerPoint[i], 2 );
    }
	
    return sqDistance <= sphere.radius * sphere.radius;
}

float LinearizeZ(float nonLinearZ)
{
	float zNear = 0.01f;
	float zFar = 1024.0f;
	
	float2 linearizeCoeff = float2((1.0f - zFar / zNear) / zFar, 1.0f / zNear);
	
	return 1.0f / (nonLinearZ * linearizeCoeff.x + linearizeCoeff.y);
}

float UnlinearizeZ(float linearZ)
{
	float zNear = 0.01f;
	float zFar = 1024.0f;
	
	float2 linearizeCoeff = float2((1.0f - zFar / zNear) / zFar, 1.0f / zNear);
	
	return (1.0f / linearZ - linearizeCoeff.y) / linearizeCoeff.x;
}

float FromNearFarTo01(float z)
{
	float zNear = 0.01f;
	float zFar = 1024.0f;
	
	return (z - zNear) / (zFar - zNear);
}

float From01ToNearFar(float z)
{
	float zNear = 0.01f;
	float zFar = 1024.0f;
	
	return lerp(zNear, zFar, z);
}

[earlydepthstencil]
Output main(Input input)
{
	Output output = (Output)0;
	
	float2 xyValues = input.position.xy / float2(1920.0f, 1080.0f);//saturate((input.clipCoord.xy / input.clipCoord.w) * 0.5f + 1.0f.xx);
	float zValue = FromNearFarTo01(LinearizeZ(input.clipCoord.z / input.clipCoord.w));
	
	uint3 address = Calculate3DAddress(float3(xyValues, zValue), CLUSTER_SIZE_XYZ);
	address = clamp(address, uint3(0, 0, 0), CLUSTER_SIZE_XYZ - uint3(1, 1, 1));
	address.x *= CLUSTER_LIGHTS_PER_CELL;
	
	uint lightCount = pointLightCluster[address];
	
	float3 diffuse = 0.1f.xxx;
	
	for (uint lightId = 1; lightId <= lightCount; lightId++)
	{
		uint lightAddress = pointLightCluster[address + uint3(lightId, 0, 0)];
		
		diffuse += pointLightBuffer[lightAddress].color;//CalculateLighting(pointLightBuffer[lightAddress], input.worldCoord, input.normal);
	}
	
	/*float4 wCoord = float4(float2(input.position.x, 1080.0f - input.position.y) / float2(1920.0f, 1080.0f), input.position.z / input.position.w, 1.0f);
	wCoord.xy = wCoord.xy * 2.0f - 1.0f.xx;
	wCoord = mul(wCoord, world);
	//wCoord /= wCoord.w;
	
	diffuse = wCoord.xyz;*/
	
	float4 wCoord = mul(world, float4((input.worldCoord / input.worldCoord.w)*0 +(clusterData[lightCount].minCornerPoint.xyz + clusterData[lightCount].maxCornerPoint.xyz) * 0.5f, 1.0f));
	
	BoundingBox bb;
	bb.minCornerPoint = -1.0f.xxxx;
	bb.maxCornerPoint = 1.0f.xxxx;
	
	float3 correctClip = float3(xyValues, input.position.z);
	correctClip.y = 1.0f - correctClip.y;
	correctClip.xy = (correctClip.xy - 0.5f.xx) * 2.0f;
	
	float4 viewCoord = mul(world, float4(correctClip, 1.0f));
	viewCoord = viewCoord / viewCoord.w;
	
	diffuse.x = (clusterData[lightCount].minCornerPoint.x <= viewCoord.x && clusterData[lightCount].maxCornerPoint.x >= viewCoord.x) ? 1.0f : 0.1f.xxx;//wCoord.xyz / wCoord.w;
	diffuse.y = (clusterData[lightCount].minCornerPoint.y <= viewCoord.y && clusterData[lightCount].maxCornerPoint.y >= viewCoord.y) ? 1.0f : 0.1f.xxx;//wCoord.xyz / wCoord.w;
	diffuse.z = (clusterData[lightCount].minCornerPoint.z <= viewCoord.z && clusterData[lightCount].maxCornerPoint.z >= viewCoord.z) ? 1.0f : 0.1f.xxx;//wCoord.xyz / wCoord.w;
	
	float4 vsLightPos = mul(world, float4(0.0f, 10.0f, 50.0f, 1.0f));
	vsLightPos /= vsLightPos.w;
	
	Sphere sph;
	sph.center = vsLightPos;//vsLightPos.xyz;//pointLightBuffer[0].position;
	sph.radius = 20.0f;//pointLightBuffer[0].radius;
	
	bool intersect = IntersectionSphereAndBoundingBox(sph, clusterData[lightCount]);//bb);//
	
	float4 clusterDataTemp = lerp(clusterData[lightCount].minCornerPoint, clusterData[lightCount].maxCornerPoint, 1.0f);
	
	float testZ = UnlinearizeZ(From01ToNearFar(address.z / (float) CLUSTER_SIZE_Z));
	float testZ2 = UnlinearizeZ(From01ToNearFar((address.z + 1) / (float) CLUSTER_SIZE_Z));
	float4 temp = (input.position.x < 960.0f) ? mul(world, float4(clusterDataTemp.xy, (testZ + testZ2), 1.0f)) : mul(world, input.clipCoord / input.clipCoord.w);
	
	//diffuse = saturate(8.0f.xxx / length(clusterDataTemp.xyz - vsLightPos.xyz));//temp.xyz / temp.w;//
	diffuse = (intersect) ? 1.0f.xxx : 0.1f.xxx;
	
	//diffuse = (input.position.x < 2960.0f) ? clusterDataTemp.xyz : input.worldCoord.xyz;
	//diffuse = 80.0f.xxx / length(clusterDataTemp.xyz - input.worldCoord);
	
	output.color = float4(diffuse, 1.0f);
	
	output.normal = float4(input.normal, 1.0f);
	
	return output;
}
